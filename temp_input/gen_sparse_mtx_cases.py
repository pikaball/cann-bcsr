#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import os
from dataclasses import dataclass
from typing import Dict, List, Tuple

import numpy as np


@dataclass(frozen=True)
class CaseSpec:
    name: str
    m: int
    k: int
    n: int


def _ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)


def _write_mtx(path: str, m: int, k: int, entries: List[Tuple[int, int, float]]) -> None:
    # MatrixMarket coordinate format is 1-based indices.
    # parse_matrix.py filters out lines starting with '%', so the first non-comment
    # line must be: "M K nnz".
    with open(path, "w", encoding="utf-8") as f:
        f.write("%%MatrixMarket matrix coordinate real general\n")
        f.write("% generated by gen_sparse_mtx_cases.py\n")
        f.write(f"{m} {k} {len(entries)}\n")
        for (r1, c1, v) in entries:
            f.write(f"{r1} {c1} {v:.6f}\n")


def _gen_sparse_entries_blockwise(
    rng: np.random.Generator,
    m: int,
    k: int,
    block_m: int = 16,
    block_k: int = 16,
    p_block: float = 0.5,
    p_elem: float = 0.1,
) -> List[Tuple[int, int, float]]:
    if m % block_m != 0 or k % block_k != 0:
        raise ValueError("This generator assumes aligned M and K (multiples of 16).")

    brs = m // block_m
    bcs = k // block_k

    entries: List[Tuple[int, int, float]] = []

    for br in range(brs):
        active_bcs = [bc for bc in range(bcs) if rng.random() < p_block]
        if not active_bcs:
            active_bcs = [int(rng.integers(0, bcs))]

        for bc in active_bcs:
            # Choose a handful of non-zeros in this block.
            total = block_m * block_k
            nnz_in_block = max(1, int(round(total * p_elem)))
            nnz_in_block = min(nnz_in_block, total)

            flat_idxs = rng.choice(total, size=nnz_in_block, replace=False)
            vals = rng.integers(1, 11, size=nnz_in_block, dtype=np.int32)

            for fi, v in zip(flat_idxs, vals):
                lr = int(fi // block_k)
                lc = int(fi % block_k)
                gr = br * block_m + lr
                gc = bc * block_k + lc
                # Store as float value (representable in float16 exactly for 1..10).
                entries.append((gr + 1, gc + 1, float(v)))

    # Make sure MatrixMarket is well-formed and deterministic order (optional but nice).
    entries.sort(key=lambda x: (x[0], x[1]))

    # Deduplicate (shouldn't happen with our generation, but safe).
    merged: Dict[Tuple[int, int], float] = {}
    for r1, c1, v in entries:
        merged[(r1, c1)] = v

    merged_entries = [(r1, c1, v) for (r1, c1), v in merged.items()]
    merged_entries.sort(key=lambda x: (x[0], x[1]))
    return merged_entries


def _sparse_to_dense(m: int, k: int, entries: List[Tuple[int, int, float]], dtype=np.float16) -> np.ndarray:
    a = np.zeros((m, k), dtype=dtype)
    for r1, c1, v in entries:
        a[r1 - 1, c1 - 1] = dtype(v)
    return a


def gen_case(out_root: str, spec: CaseSpec, seed: int) -> None:
    if spec.m % 16 != 0 or spec.k % 16 != 0:
        raise ValueError("This generator is for aligned cases only (M,K multiples of 16).")
    if spec.n % 16 != 0:
        raise ValueError("This generator targets aligned N as well (N multiple of 16).")

    rng = np.random.default_rng(seed)

    mtx_path = os.path.join(out_root, f"{spec.name}.mtx")
    sample_dir = os.path.join(out_root, spec.name)
    _ensure_dir(sample_dir)

    entries = _gen_sparse_entries_blockwise(
        rng=rng,
        m=spec.m,
        k=spec.k,
        p_block=0.6 if spec.m == 32 else 0.5,
        p_elem=0.12 if spec.m == 32 else 0.08,
    )

    # Dense B: float16 KxN, values in [1,10]
    b = rng.integers(1, 11, size=(spec.k, spec.n), dtype=np.int32).astype(np.float16)

    # Golden: float32 output (matches verify_result.py which reads float32)
    a = _sparse_to_dense(spec.m, spec.k, entries, dtype=np.float16)
    golden = (a.astype(np.float32) @ b.astype(np.float32)).astype(np.float32)

    _write_mtx(mtx_path, spec.m, spec.k, entries)

    b.tofile(os.path.join(sample_dir, "x2_gm.bin"))
    golden.tofile(os.path.join(sample_dir, "golden.bin"))

    # Helpful metadata: parse_matrix.py prints N=K, so record the intended N here.
    with open(os.path.join(sample_dir, "mnk.txt"), "w", encoding="utf-8") as f:
        f.write(f"M={spec.m}\nK={spec.k}\nN={spec.n}\n")

    print(f"[OK] {spec.name}: wrote {mtx_path}")
    print(f"     B: {os.path.join(sample_dir, 'x2_gm.bin')} (float16, shape {b.shape})")
    print(f"     golden: {os.path.join(sample_dir, 'golden.bin')} (float32, shape {golden.shape})")
    print(f"     nnz(A)={len(entries)}")


def main() -> None:
    ap = argparse.ArgumentParser(description="Generate aligned sparse A(.mtx), dense B(.bin float16), and golden C(.bin float32)")
    ap.add_argument("--out", default="/root/autodl-tmp/bcsr/temp_input", help="output root directory")
    ap.add_argument("--seed", type=int, default=20251213, help="random seed")
    args = ap.parse_args()

    specs = [
        CaseSpec(name="aligned_32", m=32, k=32, n=32),
        CaseSpec(name="aligned_64", m=64, k=64, n=64),
        CaseSpec(name="m16k16n32", m=16, k=16, n=32),
    ]

    for i, spec in enumerate(specs):
        gen_case(args.out, spec, seed=args.seed + i)


if __name__ == "__main__":
    main()
