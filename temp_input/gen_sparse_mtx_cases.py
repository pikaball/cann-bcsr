#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import os
from dataclasses import dataclass
from typing import Dict, List, Tuple

import numpy as np


@dataclass(frozen=True)
class CaseSpec:
    name: str
    m: int
    k: int
    n: int


def _ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)


def _write_mtx(path: str, m: int, k: int, entries: List[Tuple[int, int, float]]) -> None:
    # MatrixMarket coordinate format is 1-based indices.
    # parse_matrix.py filters out lines starting with '%', so the first non-comment
    # line must be: "M K nnz".
    with open(path, "w", encoding="utf-8") as f:
        f.write("%%MatrixMarket matrix coordinate real general\n")
        f.write("% generated by gen_sparse_mtx_cases.py\n")
        f.write(f"{m} {k} {len(entries)}\n")
        for (r1, c1, v) in entries:
            f.write(f"{r1} {c1} {v:.6f}\n")


def _gen_sparse_entries(
    rng: np.random.Generator,
    m: int,
    k: int,
    density: float = 0.1,
) -> List[Tuple[int, int, float]]:
    total = m * k
    nnz = int(total * density)
    nnz = max(1, min(nnz, total))

    flat_idxs = rng.choice(total, size=nnz, replace=False)
    vals = rng.integers(1, 11, size=nnz, dtype=np.int32)

    entries: List[Tuple[int, int, float]] = []
    for fi, v in zip(flat_idxs, vals):
        r = int(fi // k)
        c = int(fi % k)
        entries.append((r + 1, c + 1, float(v)))

    entries.sort(key=lambda x: (x[0], x[1]))
    return entries


def _sparse_to_dense(m: int, k: int, entries: List[Tuple[int, int, float]], dtype=np.float16) -> np.ndarray:
    a = np.zeros((m, k), dtype=dtype)
    for r1, c1, v in entries:
        a[r1 - 1, c1 - 1] = dtype(v)
    return a


def gen_case(out_root: str, spec: CaseSpec, seed: int) -> None:
    # Removed alignment checks for arbitrary MNK support.
    rng = np.random.default_rng(seed)

    mtx_path = os.path.join(out_root, f"{spec.name}.mtx")
    sample_dir = os.path.join(out_root, spec.name)
    _ensure_dir(sample_dir)

    entries = _gen_sparse_entries(
        rng=rng,
        m=spec.m,
        k=spec.k,
        density=0.1,
    )

    # Dense B: float16 KxN, values in [1,10]
    b = rng.integers(1, 11, size=(spec.k, spec.n), dtype=np.int32).astype(np.float16)

    # Golden: float32 output (matches verify_result.py which reads float32)
    a = _sparse_to_dense(spec.m, spec.k, entries, dtype=np.float16)
    golden = (a.astype(np.float32) @ b.astype(np.float32)).astype(np.float32)

    _write_mtx(mtx_path, spec.m, spec.k, entries)

    b.tofile(os.path.join(sample_dir, "x2_gm.bin"))
    golden.tofile(os.path.join(sample_dir, "golden.bin"))

    # Helpful metadata: parse_matrix.py prints N=K, so record the intended N here.
    with open(os.path.join(sample_dir, "mnk.txt"), "w", encoding="utf-8") as f:
        f.write(f"M={spec.m}\nK={spec.k}\nN={spec.n}\n")

    print(f"[OK] {spec.name}: wrote {mtx_path}")
    print(f"     B: {os.path.join(sample_dir, 'x2_gm.bin')} (float16, shape {b.shape})")
    print(f"     golden: {os.path.join(sample_dir, 'golden.bin')} (float32, shape {golden.shape})")
    print(f"     nnz(A)={len(entries)}")


def main() -> None:
    ap = argparse.ArgumentParser(description="Generate aligned sparse A(.mtx), dense B(.bin float16), and golden C(.bin float32)")
    ap.add_argument("--out", default="/root/autodl-tmp/bcsr/temp_input", help="output root directory")
    ap.add_argument("--seed", type=int, default=20251213, help="random seed")
    args = ap.parse_args()

    specs = [
        # CaseSpec(name="aligned_32", m=32, k=32, n=32),
        # CaseSpec(name="aligned_64", m=64, k=64, n=64),
        # CaseSpec(name="m16k16n32", m=16, k=16, n=32),
        # CaseSpec(name="unaligned_62", m=62, k=62, n=62),
        # CaseSpec(name="unaligned_511", m=511, k=511, n=511),
        CaseSpec(name="unaligned_1000", m=1000, k=1001, n=1001),
    ]

    for i, spec in enumerate(specs):
        gen_case(args.out, spec, seed=args.seed + i)


if __name__ == "__main__":
    main()
